`timescale 1ns/1ps
module UART_RX #(
    parameter CLOCK_FREQ = 100_000_000,   // 100 MHz
    parameter BAUD_RATE  = 9600
)(
    input  wire clk,
    input  wire reset,
    input  wire rx_in,        // Serial input line
    output reg  [7:0] rx_data, // Received byte
    output reg  done,         // Goes high for 1 cycle when a byte is ready
    output reg  busy,         // High when receiving a byte
    output reg  err           // Framing error flag
);

    // =====================================================
    // Instantiate Baud Counter
    // =====================================================
    wire baud_enable;
    wire baud_tick;

    BAUD_COUNTER #(
        .CLOCK_FREQ(CLOCK_FREQ),
        .BAUD_RATE(BAUD_RATE)
    ) baud_gen (
        .clk(clk),
        .reset(reset),
        .baud_enable(baud_enable),
        .baud_tick(baud_tick)
    );

    // =====================================================
    // Edge Detector (for start bit detection)
    // =====================================================
    reg rx_d1, rx_d2;
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            rx_d1 <= 1'b1;
            rx_d2 <= 1'b1;
        end else begin
            rx_d1 <= rx_in;
            rx_d2 <= rx_d1;
        end
    end
    wire falling_edge = (rx_d2 == 1'b1) && (rx_d1 == 1'b0);

    // =====================================================
    // FSM States
    // =====================================================
    localparam [2:0] 
        IDLE  = 3'b000,
        START = 3'b001,
        DATA  = 3'b010,
        STOP  = 3'b011,
        DONE  = 3'b100;

    reg [2:0] state, next_state;

    // =====================================================
    // Counters and Shift Register
    // =====================================================
    reg [3:0] bit_count;   // Counts 8 data bits
    reg [7:0] shift_reg;   // SIPO shift register
    reg [13:0] baud_wait;  // Counts baud ticks for 1.5 and 1 bit waits

    // =====================================================
    // Sequential FSM
    // =====================================================
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            state     <= IDLE;
            bit_count <= 0;
            shift_reg <= 0;
            rx_data   <= 0;
            done      <= 0;
            busy      <= 0;
            err       <= 0;
            baud_wait <= 0;
        end else begin
            done <= 0; // default
            case (state)
                // --------------------------------------------
                IDLE: begin
                    busy <= 0;
                    if (falling_edge) begin
                        busy      <= 1;
                        baud_wait <= 0;
                        state     <= START;
                    end
                end

                // --------------------------------------------
                START: begin
                    // Wait 1.5 baud periods before sampling start bit
                    if (baud_tick) baud_wait <= baud_wait + 1;
                    if (baud_wait == 1) begin
                        // after 1.5 baud (approx handled here)
                        if (rx_in == 0) begin
                            baud_wait <= 0;
                            bit_count <= 0;
                            state     <= DATA;
                        end else begin
                            // false start
                            state <= IDLE;
                        end
                    end
                end

                // --------------------------------------------
                DATA: begin
                    if (baud_tick) begin
                        shift_reg <= {rx_in, shift_reg[7:1]}; // sample at middle
                        bit_count <= bit_count + 1;
                        if (bit_count == 7) begin
                            state <= STOP;
                        end
                    end
                end

                // --------------------------------------------
                STOP: begin
                    if (baud_tick) begin
                        if (rx_in == 1) begin
                            rx_data <= shift_reg;
                            state   <= DONE;
                        end else begin
                            err   <= 1;  // framing error
                            state <= IDLE;
                        end
                    end
                end

                // --------------------------------------------
                DONE: begin
                    done  <= 1;
                    busy  <= 0;
                    state <= IDLE;
                end

            endcase
        end
    end

endmodule

